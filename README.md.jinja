{% for distro in Distro.registry.values() %}
![{{ distro.name }}](https://github.com/{{ repo }}/workflows/{{ distro.name | urlencode }}/badge.svg)
{% endfor %}

# {{ project_name }}

Fast & easy cross-compiling with `docker` and `distcc`.

### Use cases

* Cross-compiling for embedded systems
* Parallel build farm
* Continuous integration across a matrix of architectures

### Compiler containers

Each host container runs at least one distccd daemon. Each daemon listens on a different port, targeting a different compiler toolchain.

#### Alpine Linux

Image: `{{ alpine_3_12.host_simple_manifest_tag() }}`

| Host platform | Compiler toolchain for platform | Compiler port |
|---------------|---------------------------------|---------------|{% for host_arch in alpine3_12.host_archs %}{% for compiler_arch in alpine3_12.compiler_archs_by_host_arch[host_arch] %}
| `linux/{{ host_arch }}` | `linux/{{ compiler_arch }}` | {{ alpine3_12.ports_by_arch[compiler_arch] }} |{% endfor %}{% endfor %}

#### Arch Linux

Image: `{{ archlinux.host_simple_manifest_tag() }}`

| Host platform | Compiler toolchain for platform | Compiler port |
|---------------|---------------------------------|---------------|{% for host_arch in archlinux.host_archs %}{% for compiler_arch in archlinux.compiler_archs_by_host_arch[host_arch] %}
| `linux/{{ host_arch }}` | `linux/{{ compiler_arch }}` | {{ archlinux.ports_by_arch[compiler_arch] }} |{% endfor %}{% endfor %}

#### Debian Buster

Image: `{{ debian_buster.host_simple_manifest_tag() }}`
Slim image: `{{ debian_buster_slim.host_simple_manifest_tag() }}`

| Host platform | Compiler toolchain for platform | Compiler port |
|---------------|---------------------------------|---------------|{% for host_arch in debian_buster.host_archs %}{% for compiler_arch in debian_buster.compiler_archs_by_host_arch[host_arch] %}
| `linux/{{ host_arch }}` | `linux/{{ compiler_arch }}` | {{ debian_buster.ports_by_arch[compiler_arch] }} |{% endfor %}{% endfor %}

### Client containers

By default, the client containers will assume that a compiler image is running in the same docker network. The compiler address is configured via the environment variable `DISTCC_HOSTS`, whose default value is `172.17.0.1:<compiler-port>`, where `172.17.0.1` is the default Docker network IP and `<compiler-port>` corresponds to the table above. These defaults should work for most Docker installations. You can also use `DISTCC_HOSTS=host.docker.internal:<port>` on macOS or Windows hosts. The client containers require the `multiarch/qemu-user-static` package for emulation, which can be installed via:

macOS:
```shell
brew install qemu
docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
```

Debian/Ubuntu:
```shell
sudo apt-get update -q -y
sudo apt-get -qq install -y qemu qemu-user-static
docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
```

Arch Linux/Manjaro:
```shell
sudo pacman -Syu qemu qemu-user-static
docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
```

Windows hasn't been tested. You can install QEMU via https://www.qemu.org/download/#windows. If additional steps are required please submit a PR with instructions added to this README.

The client containers also use ccache to avoid repeat compilation. ccached object files are volatile unless you mount /root/.ccache as a volume (see examples).

#### Alpine Linux

Image: `{{ alpine_3_12.client_simple_manifest_tag() }}`

| Platform | `DISTCC_HOSTS` |
|----------|----------------|{% for compiler_arch in alpine_3_12.compiler_archs %}
| `linux/{{ compiler_arch }}` | `172.17.0.1:{{ alpine_3_12.ports_by_arch[compiler_arch] }}` |{% endfor %}

#### Arch Linux

Image: `{{ archlinux.client_simple_manifest_tag() }}`

| Platform | `DISTCC_HOSTS` |
|----------|----------------|{% for compiler_arch in archlinux.compiler_archs %}
| `linux/{{ compiler_arch }}` | `172.17.0.1:{{ archlinux.ports_by_arch[compiler_arch] }}` |{% endfor %}

#### Debian Buster

Image: `{{ debian_buster.client_simple_manifest_tag() }}`
Slim image: `{{ debian_buster_slim.client_simple_manifest_tag() }}`

| Platform | `DISTCC_HOSTS` |
|----------|----------------|{% for compiler_arch in debian_buster.compiler_archs %}
| `linux/{{ compiler_arch }}` | `172.17.0.1:{{ debian_buster.ports_by_arch[compiler_arch] }}` |{% endfor %}

### Simple example: cross-compiler

In this example, `host` is a native Debian `amd64` container which exposes an `arm64/v8` cross-compiler on port `3608`.

`client` is an emulated `arm64/v8` container that offloads all `gcc/g++/cc/etc` work to the cross-compiler exposed on `host:3608`.

The compiled object code is cached via `ccache` in a persistent volume, so that subsequent builds do not re-compile unchanged code.

```yml
version: '3'
services:
  build-host:
    image: {{ debian_buster.host_simple_manifest_tag() }}
    platform: linux/amd64
    ports:
      - 3608:3608

  build-client:
    image: {{ debian_buster.client_simple_manifest_tag() }}
    platform: linux/arm64/v8
    volumes:
      # Your code
      - .:/code
      # Cache resulting object code between builds
      - ./caches/arm64v8/ccache:/root/.ccache
    command: ./configure && make
```

### Advanced example: cross-compiler matrix for all available Alpine Linux targets

```yml
version: '3'
services:
  build-host:
    image: {{ alpine3_12.host_simple_manifest_tag() }}
    platform: linux/amd64
    ports:{% for compiler_arch in alpine3_12.compiler_archs_by_host_arch['amd64'] %}
      # {{ compiler_arch }}
      - {{ alpine3_12.ports_by_arch[compiler_arch] }}:{{ alpine3_12.ports_by_arch[compiler_arch] }}{% endfor %}
  {% for compiler_arch in alpine3_12.compiler_archs_by_host_arch['amd64'] %}
  build-client-{{ compiler_arch|arch_slug }}:
    image: {{ alpine3_12.client_simple_manifest_tag() }}
    platform: linux/{{ compiler_arch }}
    volumes:
      - .:/code
      - ./caches/amd64/ccache:/root/.ccache
    command: ./configure && make
  {% endfor %}
```

### Advanced example: cross-compiler matrix for all available Arch Linux targets

```yml
version: '3'
services:
  build-host:
    image: {{ archlinux.host_simple_manifest_tag() }}
    platform: linux/amd64
    ports:{% for compiler_arch in archlinux.compiler_archs_by_host_arch['amd64'] %}
      # {{ compiler_arch }}
      - {{ archlinux.ports_by_arch[compiler_arch] }}:{{ archlinux.ports_by_arch[compiler_arch] }}{% endfor %}
  {% for compiler_arch in archlinux.compiler_archs_by_host_arch['amd64'] %}
  build-client-{{ compiler_arch|arch_slug }}:
    image: {{ archlinux.client_simple_manifest_tag() }}
    platform: linux/{{ compiler_arch }}
    volumes:
      - .:/code
      - ./caches/amd64/ccache:/root/.ccache
    command: ./configure && make
  {% endfor %}
```

### Advanced example: cross-compiler matrix for all available Debian targets

```yml
version: '3'
services:
  build-host:
    image: {{ debian_buster.host_simple_manifest_tag() }}
    platform: linux/amd64
    ports:{% for compiler_arch in debian_buster.compiler_archs_by_host_arch['amd64'] %}
      # {{ compiler_arch }}
      - {{ debian_buster.ports_by_arch[compiler_arch] }}:{{ debian_buster.ports_by_arch[compiler_arch] }}{% endfor %}
  {% for compiler_arch in debian_buster.compiler_archs_by_host_arch['amd64'] %}
  build-client-{{ compiler_arch|arch_slug }}:
    image: {{ debian_buster.client_simple_manifest_tag() }}
    platform: linux/{{ compiler_arch }}
    volumes:
      - .:/code
      - ./caches/amd64/ccache:/root/.ccache
    command: ./configure && make
  {% endfor %}
```

### Build farm

Assuming several nodes, configured as follows:

```yml
version: '3'
services:
  build-host:
    image: {{ archlinux.host_simple_manifest_tag() }}
    ports:
      - 3704:3704
```

Where each node can be resolved via DNS as `build-host1`, `build-host2`, `build-host3`, etc, a client can distribute compilation across the nodes by using the `DISTCC_HOSTS` environment variable:

```yml
version: '3'
services:
  client:
    environment:
      - DISTCC_HOSTS="build-host1:3704 build-host2:3704 build-host3:3704"
    image: {{ archlinux.client_simple_manifest_tag() }}
    volumes:
      - .:/code
    command: ./configure && make
```

See the [distcc man page](https://linux.die.net/man/1/distcc) for documentation on `DISTCC_HOSTS`.

### Github Actions

Below is an example GitHub Actions workflow config, named say `.github/workflows/build.yml`:

```yml
name: Build project

on:
  push:
    branches: [ '*' ]
    tags: [ '*' ]

jobs:
  build:
    name: Build for archlinux {{ '${{ matrix.arch }}' }}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        arch: [ amd64, arm64v8 ]

    steps:
      - name: Setup cache
        uses: actions/cache@v2
        with:
          # Used by ccache
          path: caches
          key: {{ '${{ matrix.arch }}' }}

      - name: Checkout repo
        uses: actions/checkout@v2
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update -q -y
          sudo apt-get -qq install -y qemu qemu-user-static
          docker run --rm --privileged multiarch/qemu-user-static --reset -p yes

      - name: Build
        run: docker-compose run build-{{ '${{ matrix.arch }}' }}
```

The above workflow config assumes the repository contains a `docker-compose.yml` as follows:

```yml
version: '3'
services:
  build-host:
    image: {{ archlinux.host_simple_manifest_tag() }}
    platform: linux/amd64
    ports:
      # amd64
      - 3704:3704
      # arm64/v8
      - 3708:3708

  build-amd64:
    image: {{ archlinux.client_simple_manifest_tag() }}
    platform: linux/amd64
    depends_on: [ build-host ]
    volumes:
      # Map GitHub Actions cache to ccache via volume
      - ./caches/amd64/ccache:/root/.ccache
    command: |
      bash -c "\
        curl -LsSf https://github.com/DaveGamble/cJSON/archive/master.tar.gz -o cJSON.tar.gz; \
        tar xzf cJSON.tar.gz; \
        cd cJSON-master; \
        echo 'Waiting for builder...'; \
        sleep 10; \
        make; \
        make test; "

  build-arm64v8:
    image: {{ archlinux.client_simple_manifest_tag() }}
    platform: linux/arm64/v8
    depends_on: [ build-host ]
    volumes:
      # Map GitHub Actions cache to ccache via volume
      - ./caches/arm64v8/ccache:/root/.ccache
    command: |
      bash -c "\
        curl -LsSf https://github.com/DaveGamble/cJSON/archive/master.tar.gz -o cJSON.tar.gz; \
        tar xzf cJSON.tar.gz; \
        cd cJSON-master; \
        echo 'Waiting for builder...'; \
        sleep 10; \
        make; \
        make test; "
```

### Contributing

Adding new target operating systems should be fairly straightforward by following the existing distro patterns. Please do submit pull requests.

Most of the work happens via `builder.py build-host` and `builder.py build-client`. Pass `--help` for usage.

The easiest way to install all requirements for building is to use pipenv. `pipenv install -r requirements.txt --pre` should install the requirements, and then the build script can be run with `pipenv run ./builder.py [subcommand] [args]`.

There are some useful git hooks that can be enabled by running `git config --local core.hooksPath .githooks/`.

If you are looking for an idea, contributions for the following are especially welcome:

* Make ccache optional in the client containers via an environment variable
* A GitHub Action for GitHub Marketplace to make using these containers in CI easier
* Windows amd64 and arm64/v8 support?

### Changelog

* 2020-12-20
  * Add cross compilers for Alpine

* 2020-12-11
  * Added Alpine 3.12 images
  * Added Arch Linux ARM hosts

* 2020-12-05
  * Consolidated hosts to new container [`elijahru/build-farm`](https://hub.docker.com/repository/docker/elijahru/build-farm).
  * Consolidated clients to new container [`elijahru/build-farm-client`](https://hub.docker.com/repository/docker/elijahru/build-farm-client).
  * Added `debian:buster-slim` based containers.
  * Added `mips64le` and `arm/v5` architectures for `debian`.
